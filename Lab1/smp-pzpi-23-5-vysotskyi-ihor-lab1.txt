МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ



КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ






Звіт
з лабораторної роботи № 1
з дисципліни
«Скриптові мови програмування»









Виконав:	Перевірив:
ст. гр. ПЗПІ-23-5	ст. викладач кафедри ПІ
Висоцький І. О.	Сокорчук Ігор Петрович












2025
 
1 ІСТОРІЯ ЗМІН
№	Дата	Версія звіту	Опис змін та виправлень
1	30.05.2025	0.1	Створено розділ “Історія Змін”

   
2 ЗАВДАННЯ 
Розробити bash-скрипт для обробки розкладу занять у форматі CSV.
Скрипт має:
•	підтримувати опції --help, --version, -q/--quiet;
•	приймати назву академічної групи та CSV-файл з розкладом;
•	при відсутності аргументів – пропонувати вибір файлу та групи з доступних;
•	конвертувати вхідний файл із кодування Windows-1251 у UTF-8;
•	фільтрувати записи за групою, сортувати їх за датою;
•	форматувати вивід у вигляді CSV, сумісного з Google Calendar;
•	враховувати тип заняття (лекція, лабораторна, практика) і нумерувати лабораторні окремо.
 
3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Призначення програми
Програма призначена для автоматизованої обробки розкладу занять, що надається у форматі CSV із кодуванням Windows-1251, з подальшим формуванням відфільтрованого та відформатованого файлу розкладу, сумісного з імпортом у Google Calendar.
Основні функції програми включають:
•	вибір академічної групи та файлу розкладу;
•	конвертацію кодування файлу у UTF-8 для коректної роботи з текстом;
•	фільтрацію розкладу за заданою групою;
•	сортування занять за датою і часом;
•	форматування записів у зручний формат з датою у вигляді MM/DD/YYYY та часом у 12-годинному форматі з позначенням AM/PM;
•	нумерацію лабораторних робіт та відокремлення їх від лекцій і практичних занять;
•	підтримку різних режимів виводу, включаючи тихий режим.
Програма покликана полегшити процес перенесення академічного розкладу у електронні календарі студентів та викладачів, підвищуючи зручність планування та організації навчального процесу.
3.2 Опис основних частин коду
3.2.1  Функції довідки (рядки 4-16 в додатку B.1) та версії 
show_help — функція, що виводить інструкцію з використання скрипта.
$0 — ім’я скрипта.
exit 0 — завершення скрипта після виводу довідки.
19.	show_version() {
20.	echo "Версія скрипта: 2.0"
21.	exit 0
22.	}
Аналогічно — виводить поточну версію скрипта.
3.2.2  Ініціалізація змінних  
25.	quiet_mode=0
26.	group_name=""
27.	input_csv=""
quiet_mode — прапорець для придушення виводу.
group_name — назва групи, яку користувач вводить.
input_csv — шлях до вхідного файлу.
3.2.3  Обробка аргументів командного рядка (рядки 30–54)
•	$# — кількість аргументів.
•	case ... esac — аналог switch.
Основні варіанти:
•	--help / --version — виклик відповідних функцій.
•	-q|--quiet — активує тихий режим (quiet_mode=1).
•	Інше — зберігає назву групи та шлях до CSV.
Валідація — якщо введено більше 2 не-флагових аргументів, скрипт завершується з помилкою.
3.2.4  Вибір файлу, якщо не вказано (57 – 71 в додатку B.1)
Автоматичний пошук файлів за шаблоном TimeTable_??_??_20??.csv.
Якщо є — користувач інтерактивно вибирає файл (через select).
Якщо ні — помилка.
3.2.5  Отримання списку академічних груп (88 – 95 в додатку B.1)
З CSV витягуються всі унікальні назви груп за шаблоном типу ПЗПІ-23-12.
awk, match, substr — регулярні вирази для виділення груп.
3.2.6  Вибір групи  (106 – 127 в додатку B.1)
Якщо користувач не вказав групу або вказав неіснуючу:
•	Якщо група єдина — береться автоматично.
•	Інакше — список для вибору через select.
3.2. Фільтрація рядків (139 – 144 в додатку B.1) та сортування записів по даті (147 – 154 в додатку B.1)
Фільтрація рядків:
Витягуються лише ті рядки, які належать потрібній групі;
Для одного запису — легка фільтрація, для багатьох — група явно перевіряється.
Сортування записів по даті:
awk:
•	Вилучає дати;
•	Формує ключ у форматі YYYYMMDD для сортування;
sort — сортує за цим ключем.
3.2.8  Форматування кожного рядка (160 – 235 в додатку B.1)
Основні дії:
•	Розбиття поля line — витягуються: предмет, дата початку, час, тощо.
•	Тип пари:
o	Лк, Пз, Лб.
•	Нумерація занять (lesson_counters) за предметом, типом і датою.
•	Форматування:
o	Дата → MM/DD/YYYY
o	Час → з 24h у 12h (через функцію to_12h)
•	Вивід у форматі, сумісному з Google Calendar.
Результат виконання коду при введені некоректної кількості параметрів наведено на рис. Б.2, результат виконання коду при введені коректних параметрів наведено на рис. Б.1.
 
4 ВИСНОВКИ
Цей скрипт:
•	Приймає CSV з розкладом занять.
•	Конвертує кодування, валідує вхід.
•	Дає можливість вибору групи.
•	Фільтрує, сортує і форматує дані.
•	Генерує зручний для Google Calendar CSV.
.
 
ДОДАТОК А
ВІДЕОЗАПИС
Відеозапис презентації результатів лабораторної роботи: https://youtu.be/37y4k5aVzUo
Хронологічний опис відеозапису:
00:00 – Вітання та завдання 
00:32 – Пояснення коду скрипту 
08:51 – Демонстрація роботи скрипту 
09:51 – Результат виконання скрипту у Google sheets 
10:45 – Google Calendar
 
ДОДАТОК Б
Графічні матеріали:  
Рисунок Б.1 — Результат роботи програми у Google sheets     Рисунок Б.2 Результат роботи програми у Google Calendar
 
ДОДАТОК В
Програмний код
В.1 { smp-pzpi-23-5-vysotskyi-ihor-lab1-code } GitHub https://github.com/NureVysotskyiIhor/smp-pzpi-23-5-vysotskyi-ihor/blob/main/Lab1/smp-pzpi-23-5-vysotskyi-ihor-lab1/smp-pzpi-23-5-vysotskyi-ihor-lab1-code
1.	#!/bin/bash
2.	
3.	# Функція для відображення довідки
4.	show_help() {
5.	    echo "Використання: $0 [--help | --version] | [[-q|--quiet] [назва_групи] вхідний_файл.csv]"
6.	    echo ""
7.	    echo "Опції:"
8.	    echo "  --help              Показати цю довідку"
9.	    echo "  --version           Показати версію скрипта"
10.	    echo "  -q, --quiet         Приглушити вивід у стандартний потік"
11.	    echo ""
12.	    echo "Параметри:"
13.	    echo "  назва_групи         Назва академічної групи (наприклад, ПЗПІ-23-12)"
14.	    echo "  вхідний_файл.csv    CSV-файл з розкладом занять"
15.	    exit 0
16.	}
17.	
18.	# Функція для відображення версії
19.	show_version() {
20.	    echo "Версія скрипта: 2.0"
21.	    exit 0
22.	}
23.	
24.	# Ініціалізація змінних
25.	quiet_mode=0
26.	group_name=""
27.	input_csv=""
28.	
29.	# Обробка аргументів командного рядка
30.	while [[ $# -gt 0 ]]; do
31.	    case $1 in
32.	        --help)
33.	            show_help
34.	            ;;
35.	        --version)
36.	            show_version
37.	            ;;
38.	        -q|--quiet)
39.	            quiet_mode=1
40.	            shift
41.	            ;;
42.	        *)
43.	            if [[ -z $group_name ]]; then
44.	                group_name=$1
45.	            elif [[ -z $input_csv ]]; then
46.	                input_csv=$1
47.	            else
48.	                echo "Помилка: надлишкові аргументи" >&2
49.	                exit 1
50.	            fi
51.	            shift
52.	            ;;
53.	    esac
54.	done
55.	
56.	# Вибір файлу, якщо не вказано
57.	if [[ -z $input_csv ]]; then
58.	    available_files=$(ls TimeTable_??_??_20??.csv 2>/dev/null | sort)
59.	    if [[ -z $available_files ]]; then
60.	        echo "Помилка: не знайдено файлів формату TimeTable_??_??_20??.csv" >&2
61.	        exit 1
62.	    fi
63.	    echo "Оберіть файл:"
64.	    select input_csv in $available_files; do
65.	        if [[ -n $input_csv ]]; then
66.	            break
67.	        else
68.	            echo "Некоректний вибір. Спробуйте ще раз."
69.	        fi
70.	    done
71.	fi
72.	
73.	# Перевірка доступності файлу
74.	if [[ ! -r $input_csv ]]; then
75.	    echo "Помилка: файл недоступний для читання: $input_csv" >&2
76.	    exit 1
77.	fi
78.	
79.	# Конвертація кодування та очищення файлу
80.	temp_utf8=$(mktemp)
81.	iconv -f WINDOWS-1251 -t UTF-8 "$input_csv" | tr -d '\r' > "$temp_utf8" || {
82.	    echo "Помилка: не вдалося конвертувати кодування файлу" >&2
83.	    rm "$temp_utf8"
84.	    exit 1
85.	}
86.	
87.	# Отримання списку груп після "DL"
88.	groups=($(iconv -f WINDOWS-1251 -t UTF-8 "$input_csv" 2>/dev/null | tr '\r' '\n' | awk -F'","' '
89.	    NR > 1 {
90.	        if (match($0, /[A-Za-zА-Яа-яіїєґІЇЄҐ]+-[0-9]{2}-[0-9]{1,2}/)) {
91.	            group = substr($0, RSTART, RLENGTH);
92.	            print group;
93.	        }
94.	    }
95.	' | sort | uniq))
96.	
97.	group_count=${#groups[@]}
98.	
99.	if [[ $group_count -eq 0 ]]; then
100.	    echo "Помилка: у файлі не знайдено жодної групи" >&2
101.	    rm "$temp_utf8"
102.	    exit 1
103.	fi
104.	
105.	# Вибір групи, якщо не вказано або не знайдено
106.	if [[ -z "$group_name" || ! " ${groups[@]} " =~ " $group_name " ]]; then
107.	    if [[ $group_count -eq 1 ]]; then
108.	        group_name="${groups[0]}"
109.	        echo "Використовується єдина знайдена група: $group_name" >&2
110.	    else
111.	        if [[ -n "$group_name" ]]; then
112.	            echo "Помилка: вказана група '$group_name' не знайдена у файлі." >&2
113.	        fi
114.	        echo "Доступні групи:"
115.	        for group in "${groups[@]}"; do
116.	            echo "$group"
117.	        done
118.	        echo "Оберіть групу:"
119.	        select group_name in "${groups[@]}"; do
120.	            if [[ -n "$group_name" ]]; then
121.	                break
122.	            else
123.	                echo "Некоректний вибір. Спробуйте ще раз."
124.	            fi
125.	        done
126.	    fi
127.	fi
128.	
129.	# Формування імені вихідного файлу
130.	date_segment=$(echo "$input_csv" | sed 's/TimeTable_\(.*\).csv/\1/')
131.	output_csv="Google_TimeTable_${date_segment}.csv"
132.	
133.	# Повідомлення про обробку
134.	if [[ $quiet_mode -eq 0 ]]; then
135.	    echo "Обробка записів для групи: $group_name"
136.	fi
137.	
138.	# Фільтрація записів для вибраної групи
139.	temp_filtered=$(mktemp)
140.	if [[ $group_count -eq 1 ]]; then
141.	    grep -o "\"[^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\"" "$temp_utf8" > "$temp_filtered"
142.	else
143.	    grep -o "\"$group_name - [^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\",\"[^\"]*\"" "$temp_utf8" > "$temp_filtered"
144.	fi
145.	
146.	# Сортування записів за датою
147.	temp_sorted=$(mktemp)
148.	awk -F'"' '
149.	    $4 !~ /\/Дата\*\// && $2 !~ /Тема/ && $4 != "" {
150.	        split($4, date_parts, ".")
151.	        sort_date = sprintf("%04d%02d%02d", date_parts[3], date_parts[2], date_parts[1])
152.	        print sort_date "|" $6 "|" $0
153.	    }
154.	' "$temp_filtered" | sort > "$temp_sorted"
155.	
156.	# Запис заголовку у вихідний файл
157.	echo "Subject,Start Date,Start Time,End Date,End Time,Description" > "$output_csv"
158.	
159.	# Обробка та форматування записів
160.	awk -F'|' '
161.	    function to_12h(time_24h) {
162.	        split(time_24h, parts, ":")
163.	        hour = parts[1] + 0
164.	        minute = parts[2]
165.	        if(hour == 0) {
166.	            hour = 12
167.	            ampm = "AM"
168.	        } else if(hour == 12) {
169.	            ampm = "PM"
170.	        } else if(hour > 12) {
171.	            hour = hour - 12
172.	            ampm = "PM"
173.	        } else {
174.	            ampm = "AM"
175.	        }
176.	        return hour ":" minute " " ampm
177.	    }
178.	    {
179.	        line = $3
180.	        split(line, fields, "\"")
181.	        subject = fields[2]
182.	        start_date = fields[4]
183.	        start_time = fields[6]
184.	        end_date = fields[8]
185.	        end_time = fields[10]
186.	        clean_subject = subject
187.	        gsub(/^[А-ЯІЇЄа-яіїє0-9-]+ - /, "", clean_subject)
188.	        if(clean_subject ~ /Лб/) {
189.	            type = "Лб"
190.	            key_subject = clean_subject
191.	            gsub(/ DL.*/, "", key_subject)
192.	            key = key_subject "_" type "_" start_date
193.	        } else if(clean_subject ~ /Пз/) {
194.	            type = "Пз"
195.	            key_subject = clean_subject
196.	            gsub(/ DL.*/, "", key_subject)
197.	            key = key_subject "_" type
198.	        } else {
199.	            type = "Лк"
200.	            key_subject = clean_subject
201.	            gsub(/ DL.*/, "", key_subject)
202.	            key = key_subject "_" type
203.	        }
204.	        if(key in lesson_counters) {
205.	            if(type != "Лб") {
206.	                lesson_counters[key]++
207.	            }
208.	        } else {
209.	            if(type == "Лб") {
210.	                max_num = 0
211.	                for(k in lesson_counters) {
212.	                    if(index(k, key_subject "_" type "_") == 1) {
213.	                        if(lesson_counters[k] > max_num) {
214.	                            max_num = lesson_counters[k]
215.	                        }
216.	                    }
217.	                }
218.	                lesson_counters[key] = max_num + 1
219.	            } else {
220.	                lesson_counters[key] = 1
221.	            }
222.	        }
223.	        lesson_number = lesson_counters[key]
224.	        split(start_date, sd_parts, ".")
225.	        split(end_date, ed_parts, ".")
226.	        formatted_start_date = sd_parts[2] "/" sd_parts[1] "/" sd_parts[3]
227.	        formatted_end_date = ed_parts[2] "/" ed_parts[1] "/" ed_parts[3]
228.	        formatted_start_time = to_12h(start_time)
229.	        formatted_end_time = to_12h(end_time)
230.	        subject_output = clean_subject "; №" lesson_number
231.	        description = clean_subject
232.	        record = "\"" subject_output "\",\"" formatted_start_date "\",\"" formatted_start_time "\",\"" formatted_end_date "\",\"" formatted_end_time "\",\"" description "\""
233.	        print record
234.	    }
235.	' "$temp_sorted" >> "$output_csv"
236.	
237.	# Очищення тимчасових файлів
238.	rm "$temp_filtered" "$temp_sorted" "$temp_utf8"
239.	
240.	# Вивід результату, якщо не в тихому режимі
241.	if [[ $quiet_mode -eq 0 ]]; then
242.	    cat "$output_csv"
243.	fi
